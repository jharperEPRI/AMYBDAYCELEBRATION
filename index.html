
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  manifest.json
  <title>Birthday Quest ‚Äî Hidden Objects</title>
  <meta name="theme-color" content="#007aff" />
  <style>
    :root { --primary:#007aff; --gray:#6b7280; --green:#10b981; --red:#ef4444; }
    * { box-sizing: border-box; }
    body { margin:0; font:16px/1.6 system-ui, -apple-system, Segoe UI, Roboto; color:#111; background:#fff; }
    header { padding:1rem; text-align:center; border-bottom:1px solid #eee; }
    header h1 { margin:.2rem 0; }
    header p { color:var(--gray); margin:.2rem 0 .6rem; }
    .progress { width:92%; max-width:720px; margin:.5rem auto 1rem; background:#f4f4f5; border-radius:999px; overflow:hidden; height:10px; }
    .bar { height:100%; background:linear-gradient(90deg, var(--primary), #34d399); width:0%; transition:width .4s; }
    main { max-width:980px; margin:0 auto; padding:1rem; }
    .card { border:1px solid #e5e7eb; border-radius:14px; padding:1rem; margin:1rem 0; box-shadow:0 1px 2px rgba(0,0,0,.04); }
    .title { display:flex; justify-content:space-between; align-items:center; gap:1rem; }
    .meta { font-size:.95rem; color:var(--gray); }
    .imgWrap { position:relative; width:100%; max-width:900px; margin:.8rem auto; border-radius:12px; overflow:hidden; background:#f9fafb; }
    .imgWrap img { width:100%; display:block; touch-action:manipulation; }
    .hotspot { position:absolute; border:2px dashed rgba(16,185,129,.0); border-radius:8px; pointer-events:none; }
    .hotspot.found { border-color: rgba(16,185,129,.8); box-shadow: 0 0 0 3px rgba(16,185,129,.25) inset; }
    .label { display:inline-block; background:#00000099; color:#fff; border-radius:10px; padding:.2rem .5rem; font-size:.85rem; margin:.3rem .3rem 0 0; }
    .labels { margin-top:.4rem; }
    .btn { background:var(--primary); color:#fff; border:none; border-radius:12px; padding:.6rem 1rem; font-weight:600; cursor:pointer; }
    .btn.secondary { background:#6d28d9; }
    .btn.ghost { background:#f4f4f5; color:#111; }
    .result { margin:.6rem 0; }
    .success { color:var(--green); font-weight:600; }
    .warn { color:var(--red); }
    .nextPanel { margin-top:.8rem; padding:.8rem; background:#f9fafb; border:1px solid #e5e7eb; border-radius:12px; }
    footer { text-align:center; color:var(--gray); padding:2rem 1rem; }
    .drawRect { position:absolute; border:2px dashed #ff9800; background:rgba(255,152,0,.12); pointer-events:none; }
  </style>
</head>
<body>
<header>
  <h1>üéâ Birthday Quest ‚Äî Hidden Objects</h1>
  <p>Find the hidden items in each image to reveal the next location.</p>
  <div class="progress"><div class="bar" id="bar"></div></div>
  <p class="meta">Tip: In Safari, tap <b>Share</b> ‚Üí <b>Add to Home Screen</b> for an app‚Äëlike experience.</p>
</header>

<main id="app"></main>
<footer>Made with ‚ù§Ô∏è by Jim & family</footer>

<script>
// =============================
// CONFIG: puzzles (sequential)
// =============================
const PUZZLES = [
  {
    id:"villagegrind",
    name:"Hidden Objects ‚Äî Coffee & Pastries",
    img:"img/village-grind.jpg?v=2",         // project-relative path
    reveal:{ title:"Next: The Village Grind", maps:"https://maps.apple.com/?q=The%20Village%20Grind" },
    hotspots:[


      
      { x:36.0, y:62.5, w:9.0, h:12.0, label:"pancake" },
      { x:56.99, y:76.15, w:15.15, h:24.14, label:"sippy cup" }
    ]
  },
  {
    id:"morninggoat",
    name:"Hidden Objects ‚Äî Brunch Clues",
    img:"img/morning-goat.jpg",
    reveal:{ title:"Next: The Morning Goat", maps:"https://maps.apple.com/?q=The%20Morning%20Goat" },
    hotspots:[
      { x:18.0, y:54.0, w:10.0, h:10.0, label:"Goat icon" },
      { x:58.0, y:38.0, w:12.0, h:9.0,  label:"Latte art" },
      { x:73.0, y:66.0, w:8.0,  h:7.0,  label:"Menu header" }
    ]
  },
  {
    id:"paintingtwist",
    name:"Hidden Objects ‚Äî Studio Details",
    img:"img/painting-with-a-twist.jpg",
    reveal:{ title:"Next: Painting with a Twist (1‚Äì3 PM)", maps:"https://maps.apple.com/?q=Painting%20With%20a%20Twist" },
    hotspots:[
      { x:44.0, y:40.0, w:10.0, h:12.0, label:"Paint brush" },
      { x:64.0, y:55.0, w:12.0, h:10.0, label:"Palette" }
    ]
  },
  {
    id:"swamprabbitcafe",
    name:"Hidden Objects ‚Äî Caf√© & Trail",
    img:"img/swamp-rabbit-cafe.jpg",
    reveal:{ title:"Next: Swamp Rabbit Caf√© & Trail", maps:"https://maps.apple.com/?q=Swamp%20Rabbit%20Cafe%20and%20Grocery" },
    hotspots:[
      { x:26.0, y:42.0, w:10.0, h:10.0, label:"Rabbit logo" },
      { x:70.0, y:60.0, w:11.0, h:11.0, label:"Bike wheel" },
      { x:52.0, y:28.0, w:14.0, h:8.0,  label:"Trail sign" }
    ]
  },
  {
    id:"hollowedearth",
    name:"Hidden Objects ‚Äî Clay & Wheels",
    img:"img/hollowed-earth.jpg",
    reveal:{ title:"Next: Hollowed Earth Pottery (6‚Äì7:30 PM)", maps:"https://maps.apple.com/?q=Hollowed%20Earth%20Pottery" },
    hotspots:[
      { x:42.0, y:58.0, w:12.0, h:12.0, label:"Potter‚Äôs wheel" },
      { x:18.0, y:38.0, w:10.0, h:10.0, label:"Glaze shelf" }
    ]
  },
  {
    id:"trio",
    name:"Hidden Objects ‚Äî Brick Oven",
    img:"img/trio.jpg",
    reveal:{ title:"Next: Trio ‚Äî Family Favorite Dinner", maps:"https://maps.apple.com/?q=Trio%20A%20Brick%20Oven%20Cafe" },
    hotspots:[
      { x:60.0, y:40.0, w:14.0, h:12.0, label:"Brick oven" },
      { x:32.0, y:62.0, w:10.0, h:10.0, label:"Pizza paddle" }
    ]
  },
  {
    id:"humane",
    name:"Hidden Objects ‚Äî Shelter Day",
    img:"img/humane-society.jpg",
    reveal:{ title:"Finale: Greenville Humane Society (Sun 10:30 AM)", maps:"https://maps.apple.com/?q=Greenville%20Humane%20Society" },
    hotspots:[
      { x:24.0, y:52.0, w:12.0, h:10.0, label:"Leash" },
      { x:68.0, y:48.0, w:12.0, h:12.0, label:"Water bowl" }
    ]
  }
];

// =============================
// STATE & UTILS
// =============================
const DBKEY = 'quest2026-hidden';
const readDB = () => { try { return JSON.parse(localStorage.getItem(DBKEY))||{ idx:0, found:{} }; } catch(e){ return { idx:0, found:{} }; } };
const writeDB = (d) => localStorage.setItem(DBKEY, JSON.stringify(d));
const pctToPx = (pct, size) => pct/100 * size;
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const authorMode = new URL(location.href).searchParams.get('author') === '1';

// Resolve **project-relative** asset paths safely (GitHub Pages-friendly)
function resolveAsset(path) {
  const safe = path.startsWith('/') ? path.slice(1) : path; // strip leading slash if any
  return new URL(safe, location.href).toString();
}

// =============================
// RENDER CURRENT PUZZLE
// =============================
function render(){
  const state = readDB();
  const idx = clamp(state.idx, 0, PUZZLES.length-1);
  const p = PUZZLES[idx];
  const app = document.getElementById('app');
  app.innerHTML = '';

  const completed = Object.keys(state.found).filter(id => state.found[id]?.all).length;
  document.getElementById('bar').style.width = Math.round(completed/PUZZLES.length*100) + '%';

  const card = document.createElement('div'); card.className='card';
  const labelsHtml = p.hotspots.map(h => `<span class="label">${h.label}</span>`).join('');
  card.innerHTML = `
    <div class="title">
      <h2>${p.name}</h2>
      <span class="meta">${idx+1} / ${PUZZLES.length}</span>
    </div>
    <div class="labels">${labelsHtml}</div>
    <div class="imgWrap">
      <img id="pimg" alt="Hidden objects image"/>
    </div>
    <div class="result" id="result"></div>
    <div class="nextPanel" id="nextPanel" style="display:none">
      <p class="success">All items found! üéä</p>
      <p><strong>${p.reveal.title}</strong></p>
      <p>${p.reveal.maps}Open in Apple Maps</a></p>
      ${idx < PUZZLES.length-1 ? `<button class="btn secondary" id="nextBtn">Reveal Next Image</button>` : `<p>üíú You reached the finale! Have an amazing day.</p>`}
    </div>
    ${authorMode ? `<p class="meta">Author mode: drag to draw rectangles; see console for JSON.</p>` : ''}
  `;
  app.appendChild(card);

  const img = card.querySelector('#pimg');
  const result = card.querySelector('#result');
  const nextPanel = card.querySelector('#nextPanel');

  // *** Critical line: set src with safe project-relative resolution ***
  img.src = resolveAsset(p.img);

  // Diagnostics: show success or failure and the exact URL
  img.addEventListener('load', () => {
    console.log('Loaded image:', img.src);
  });
  img.addEventListener('error', () => {
    console.error('Image failed:', img.src);
    result.innerHTML = `<p class="warn">
      Image failed to load: <code>${img.src}</code>.<br>
      If this is a GitHub Pages <em>project</em> site, ensure your path is relative (e.g., <code>img/‚Ä¶</code>) and the file exists in the repository.
    </p>`;
  });

  img.addEventListener('load', () => {
    const rect = img.getBoundingClientRect();
    const wrap = img.parentElement;

    // Restore found state for current puzzle
    const s = readDB();
    const fset = s.found[p.id]?.set || new Array(p.hotspots.length).fill(false);

    // Place invisible hotspot boxes (turn green when found)
    p.hotspots.forEach((h, i) => {
      const hs = document.createElement('div'); hs.className='hotspot';
      const x = pctToPx(h.x, rect.width), y = pctToPx(h.y, rect.height);
      const w = pctToPx(h.w, rect.width), hpx = pctToPx(h.h, rect.height);
      hs.style.left = x+'px'; hs.style.top = y+'px'; hs.style.width = w+'px'; hs.style.height = hpx+'px';
      if (fset[i]) hs.classList.add('found');
      wrap.appendChild(hs);
    });

    // Tap/click detection
    wrap.addEventListener('click', (ev) => {
      if (authorMode) return;
      const r = img.getBoundingClientRect();
      const cx = ev.clientX - r.left; const cy = ev.clientY - r.top;
      const { hitIndex } = detectHit(p.hotspots, r.width, r.height, cx, cy, fset);
      if (hitIndex !== -1) {
        fset[hitIndex] = true;
        const hs = wrap.querySelectorAll('.hotspot')[hitIndex];
        hs.classList.add('found');
        saveFound(p.id, fset);
        result.innerHTML = `<p class="success">Found: ${p.hotspots[hitIndex].label}</p>`;
        confetti(10);
        if (fset.every(Boolean)) {
          markComplete(p.id);
          nextPanel.style.display = 'block';
        }
      } else {
        result.innerHTML = `<p>Keep hunting‚Ä¶</p>`;
      }
    });

    // Author mode: draw rectangles, export JSON percentage coords
    if (authorMode) enableAuthorDraw(wrap, img);
  });

  // Next button
  const nextBtn = card.querySelector('#nextBtn');
  if (nextBtn) nextBtn.addEventListener('click', () => {
    const s = readDB(); s.idx = clamp(s.idx+1, 0, PUZZLES.length-1); writeDB(s);
    render();
  });
}

function detectHit(hotspots, w, h, cx, cy, fset){
  for (let i=0; i<hotspots.length; i++){
    if (fset[i]) continue;
    const hs = hotspots[i];
    const rx = pctToPx(hs.x, w), ry = pctToPx(hs.y, h);
    const rw = pctToPx(hs.w, w), rh = pctToPx(hs.h, h);
    if (cx >= rx && cx <= rx+rw && cy >= ry && cy <= ry+rh) return { hitIndex:i };
  }
  return { hitIndex:-1 };
}

// =============================
// STATE HELPERS
// =============================
function saveFound(id, set){
  const s = readDB(); s.found[id] = s.found[id] || {};
  s.found[id].set = set;
  writeDB(s);
}
function markComplete(id){
  const s = readDB(); s.found[id] = s.found[id] || {};
  s.found[id].all = true; writeDB(s);
  const completed = Object.keys(s.found).filter(k => s.found[k]?.all).length;
  document.getElementById('bar').style.width = Math.round(completed/PUZZLES.length*100) + '%';
}

// =============================
// CONFETTI (emoji)
// =============================
function confetti(n=18){
  for(let i=0;i<n;i++){
    const d=document.createElement('div');
    d.textContent='üéä'; d.style.position='fixed'; d.style.left=Math.random()*100+'%';
    d.style.top='-20px'; d.style.fontSize='20px'; d.style.transition='transform 1.2s ease, opacity 1.2s';
    document.body.appendChild(d);
    setTimeout(()=>{ d.style.transform=`translateY(${80+Math.random()*70}vh)`; d.style.opacity='0'; }, 10);
    setTimeout(()=> d.remove(), 1400);
  }
}





// =============================
// AUTHOR MODE ‚Äî robust pointer draw + reliable JSON copy
// =============================
function enableAuthorDraw(wrap, img){
  const MIN_DRAG_PX = 3;           // require at least a tiny drag
  const drawn = [];                // hotspots collected for this image
  let start = null;                // {x,y} in image coords
  let rectEl = null;               // the visual rectangle overlay

  const getImgRect = () => img.getBoundingClientRect();
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const toPct = (px, size) => ((px / size) * 100);

  // Normalize pointer coords to image-local coordinates
  function localPoint(evt) {
    const r = getImgRect();
    const clientX = evt.clientX ?? (evt.touches && evt.touches[0]?.clientX);
    const clientY = evt.clientY ?? (evt.touches && evt.touches[0]?.clientY);
    return {
      x: clamp(clientX - r.left, 0, r.width),
      y: clamp(clientY - r.top,  0, r.height),
      rect: r
    };
  }

  // Start drawing
  function onPointerDown(evt){
    // Only left button for mouse; always ok for touch
    if (evt.button !== undefined && evt.button !== 0) return;
    const p = localPoint(evt);
    start = { x: p.x, y: p.y, rect: p.rect };

    rectEl = document.createElement('div');
    rectEl.className = 'drawRect';
    rectEl.style.left = `${start.x}px`;
    rectEl.style.top  = `${start.y}px`;
    rectEl.style.width  = '0px';
    rectEl.style.height = '0px';
    wrap.appendChild(rectEl);

    // capture subsequent events
    wrap.setPointerCapture?.(evt.pointerId);
  }

  // Update rectangle while dragging
  function onPointerMove(evt){
    if (!start || !rectEl) return;
    const p = localPoint(evt);
    const w = p.x - start.x;
    const h = p.y - start.y;

    const left = w < 0 ? p.x : start.x;
    const top  = h < 0 ? p.y : start.y;

    rectEl.style.left   = `${left}px`;
    rectEl.style.top    = `${top}px`;
    rectEl.style.width  = `${Math.abs(w)}px`;
    rectEl.style.height = `${Math.abs(h)}px`;
  }

  // Finish rectangle and store JSON
  function onPointerUp(evt){
    if (!start || !rectEl) return;
    const r = getImgRect();

    // Parse computed numbers safely
    const leftPx = Number.parseFloat(rectEl.style.left)  || 0;
    const topPx  = Number.parseFloat(rectEl.style.top)   || 0;
    const wPx    = Number.parseFloat(rectEl.style.width) || 0;
    const hPx    = Number.parseFloat(rectEl.style.height)|| 0;

    // Enforce min size to avoid accidental clicks
    if (wPx < MIN_DRAG_PX || hPx < MIN_DRAG_PX) {
      rectEl.remove();
      start = null; rectEl = null;
      return;
    }

    // Clamp within image bounds (belt & suspenders)
    const clLeft = clamp(leftPx, 0, r.width);
    const clTop  = clamp(topPx,  0, r.height);
    const clW    = clamp(wPx,    0, r.width - clLeft);
    const clH    = clamp(hPx,    0, r.height - clTop);

    // Convert to % and round to 2 decimals
    const json = {
      x: +toPct(clLeft, r.width).toFixed(2),
      y: +toPct(clTop,  r.height).toFixed(2),
      w: +toPct(clW,    r.width).toFixed(2),
      h: +toPct(clH,    r.height).toFixed(2),
      label: "New item"
    };

    drawn.push(json);
    console.log('Hotspot JSON added:', json);

    start = null; rectEl = null;
    // release pointer capture
    try { wrap.releasePointerCapture?.(evt.pointerId); } catch {}
  }

  // Hook pointer events (works for mouse + touch)
  wrap.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup',   onPointerUp);
  window.addEventListener('pointercancel', () => { start=null; rectEl=null; });

  // --- Copy JSON button ---
  const copyBtn = document.createElement('button');
  copyBtn.className = 'btn ghost';
  copyBtn.textContent = 'Copy hotspots to clipboard';
  copyBtn.style.marginTop = '.6rem';

  copyBtn.addEventListener('click', async () => {
    const text = JSON.stringify(drawn, null, 2);
    if (!text || drawn.length === 0) {
      alert('No hotspots drawn yet.\nDrag to draw rectangles on the image, then click Copy.');
      return;
    }
    try {
      await navigator.clipboard.writeText(text);
      alert(`Copied ${drawn.length} hotspot(s) to clipboard.\nPaste into PUZZLES[].hotspots in index.html.`);
      console.log('Copied hotspots JSON:\n', text);
    } catch (err) {
      console.error('Clipboard write failed:', err);
      alert('Copy failed.\nOpen DevTools ‚Üí Console and copy the logged JSON there.');
      console.log('Hotspots (fallback):\n', text);
    }
  });

  // Reset button
  const resetBtn = document.createElement('button');
  resetBtn.className = 'btn ghost';
  resetBtn.textContent = 'Reset drawn hotspots';
  resetBtn.style.marginLeft = '.5rem';
  resetBtn.addEventListener('click', () => {
    drawn.length = 0;
    [...wrap.querySelectorAll('.drawRect')].forEach(el => el.remove());
    alert('Cleared current hotspots. Draw new rectangles and copy again.');
  });

  const controls = document.createElement('div');
  controls.style.marginTop = '.6rem';
  controls.appendChild(copyBtn);
  controls.appendChild(resetBtn);
  wrap.parentElement.appendChild(controls);
}




// =============================
// Service worker registration
// (Re-enable once images render correctly)
// =============================
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js'); // keep as-is; your sw.js now uses relative paths
}

// Start
render();
</script>
</body>
</html>




